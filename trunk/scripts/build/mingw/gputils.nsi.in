# gputils.nsi - NSIS installer script for gputils
#
# Copyright (c) 2004 Borut Razem
#
# This file is part of gputils.
#
#  This software is provided 'as-is', without any express or implied
#  warranty.  In no event will the authors be held liable for any damages
#  arising from the use of this software.
#
#  Permission is granted to anyone to use this software for any purpose,
#  including commercial applications, and to alter it and redistribute it
#  freely, subject to the following restrictions:
#
#  1. The origin of this software must not be misrepresented; you must not
#     claim that you wrote the original software. If you use this software
#     in a product, an acknowledgment in the product documentation would be
#     appreciated but is not required.
#  2. Altered source versions must be plainly marked as such, and must not be
#     misrepresented as being the original software.
#  3. This notice may not be removed or altered from any source distribution.
#
#  Borut Razem
#  borut.razem@siol.net

!include "MUI.nsh"

SetCompressor lzma

!define GPUTILS_ROOT "."

!define DEV_ROOT "${GPUTILS_ROOT}"

InstType "Full (Bin, Doc, Hdr, Lkr, Pub)"
InstType "Compact (Bin, Doc)"

;--------------------------------
; Variables

Var MUI_STARTMENUPAGE_VARIABLE

;--------------------------------
!define MUI_ABORTWARNING

!insertmacro MUI_PAGE_WELCOME
!insertmacro MUI_PAGE_LICENSE "${GPUTILS_ROOT}\COPYING.txt"
!define MUI_STARTMENUPAGE_DEFAULTFOLDER "gputils"
!define MUI_STARTMENUPAGE_REGISTRY_ROOT "HKLM"
!define MUI_STARTMENUPAGE_REGISTRY_KEY "Software\Microsoft\Windows\CurrentVersion\Uninstall\gputils"
!define MUI_STARTMENUPAGE_REGISTRY_VALUENAME "NSIS:StartMenuDir"
!define MUI_STARTMENUPAGE_NODISABLE
!insertmacro MUI_PAGE_STARTMENU Application $MUI_STARTMENUPAGE_VARIABLE
!insertmacro MUI_PAGE_COMPONENTS
!insertmacro MUI_PAGE_DIRECTORY
!insertmacro MUI_PAGE_INSTFILES
!insertmacro MUI_PAGE_FINISH

!insertmacro MUI_UNPAGE_INSTFILES

!insertmacro MUI_LANGUAGE "English"

Name "gputils"
BrandingText ""
OutFile "@VERSION@-@RELEASE@.exe"
InstallDir "$PROGRAMFILES\gputils"
ShowInstDetails show
ShowUnInstDetails show

Function .onInit
  ; Uninstall the old version, if present
  ReadRegStr $R0 HKLM \
  "Software\Microsoft\Windows\CurrentVersion\Uninstall\$(^Name)" \
  "UninstallString"
  StrCmp $R0 "" inst

  MessageBox MB_OKCANCEL|MB_ICONEXCLAMATION \
  "$(^Name) is already installed. $\n$\nClick 'OK' to remove the \
  previous version or 'Cancel' to cancel this upgrade." \
  IDOK uninst
  Abort

uninst:
  ; Run the uninstaller
  ClearErrors
  ExecWait '$R0 _?=$INSTDIR' ;Do not copy the uninstaller to a temp file

  ;IfErrors no_remove_uninstaller
  ;  ; You can either use Delete /REBOOTOK in the uninstaller or add some code
  ;  ; here to remove to remove the uninstaller. Use a registry key to check
  ;  ; whether the user has chosen to uninstall. If you are using an uninstaller
  ;  ; components page, make sure all sections are uninstalled.
  ;no_remove_uninstaller:

  Goto done
inst:

  ; Install the new version
  MessageBox MB_YESNO|MB_ICONQUESTION "This will install $(^Name). Do you wish to continue?" IDYES +2
  Abort

done:
FunctionEnd

Section -Common
  SetOutPath "$INSTDIR"
  File "${GPUTILS_ROOT}\COPYING.txt"
  File "${GPUTILS_ROOT}\ChangeLog.txt"
  File "${GPUTILS_ROOT}\README.txt"
  File "${GPUTILS_ROOT}\AUTHORS.txt"
SectionEnd

Section "gputils application files"
  SectionIn 1 2 RO
  SetOutPath "$INSTDIR\bin"
  File "${GPUTILS_ROOT}\gpal\gpal.exe"
  File "${GPUTILS_ROOT}\gpasm\gpasm.exe"
  File "${GPUTILS_ROOT}\gplink\gplink.exe"
  File "${GPUTILS_ROOT}\gputils\gplib.exe"
  File "${GPUTILS_ROOT}\gputils\gpvc.exe"
  File "${GPUTILS_ROOT}\gputils\gpvo.exe"
SectionEnd

Section "gputils documentation"
  SectionIn 1 2
  SetOutPath "$INSTDIR\doc"
  File "${GPUTILS_ROOT}\doc\gputils.pdf"
SectionEnd

Section "gputils header files"
  SectionIn 1
  SetOutPath "$INSTDIR\header"
  File "${DEV_ROOT}\header\*.inc"

  ; Set GPUTILS_HEADER_PATH environment variable
  Push "GPUTILS_HEADER_PATH"  ; name
  Push "$INSTDIR\header"      ; value
  Call WriteEnvStr
SectionEnd

Section "gputils lkr files"
  SectionIn 1
  SetOutPath "$INSTDIR\lkr"
  File "${DEV_ROOT}\lkr\*.lkr"

  ; Set GPUTILS_LKR_PATH environment variable
  Push "GPUTILS_LKR_PATH"  ; name
  Push "$INSTDIR\lkr"      ; value
  Call WriteEnvStr
SectionEnd

Section "gputils pub files"
  SectionIn 1
  SetOutPath "$INSTDIR\pub"
  File "${DEV_ROOT}\pub\*.pub"

  ; Set GPUTILS_PUB_PATH environment variable
  Push "GPUTILS_PUB_PATH"  ; name
  Push "$INSTDIR\pub"      ; value
  Call WriteEnvStr
SectionEnd

Section -Icons
!insertmacro MUI_STARTMENU_WRITE_BEGIN Application
  CreateDirectory "$SMPROGRAMS\$MUI_STARTMENUPAGE_VARIABLE"
  CreateShortCut "$SMPROGRAMS\$MUI_STARTMENUPAGE_VARIABLE\gputils on the Web.lnk" "$INSTDIR\gputils.url"
  CreateShortCut "$SMPROGRAMS\$MUI_STARTMENUPAGE_VARIABLE\Uninstall gputils.lnk" "$INSTDIR\uninstall.exe"
  CreateShortCut "$SMPROGRAMS\$MUI_STARTMENUPAGE_VARIABLE\Documentation.lnk" "$INSTDIR\doc\gputils.pdf"
  CreateShortCut "$SMPROGRAMS\$MUI_STARTMENUPAGE_VARIABLE\README.lnk" "$INSTDIR\README.TXT"
  CreateShortCut "$SMPROGRAMS\$MUI_STARTMENUPAGE_VARIABLE\Change Log.lnk" "$INSTDIR\ChangeLog.txt"
  CreateShortCut "$SMPROGRAMS\$MUI_STARTMENUPAGE_VARIABLE\GPL 2 License.lnk" "$INSTDIR\COPYING.txt"
!insertmacro MUI_STARTMENU_WRITE_END
SectionEnd

Section -INI
  WriteIniStr "$INSTDIR\gputils.url" "InternetShortcut" "URL" "http://gputils.sourceforge.net/"
SectionEnd

Section -PostInstall
  WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\gputils" "DisplayName" "gputils"
  WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\gputils" "UninstallString" "$INSTDIR\uninstall.exe"
  WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\gputils" "Publisher" "gputils.sourceforge.net"
  WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\gputils" "URLInfoAbout" "http://gputils.sourceforge.net/"
  WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\gputils" "HelpLink" "http://gputils.sourceforge.net/"
  WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\gputils" "URLUpdateInfo" "http://gputils.sourceforge.net/"
  WriteUninstaller "$INSTDIR\uninstall.exe"
SectionEnd

Section -AddToPath
  MessageBox MB_ICONQUESTION|MB_YESNO|MB_DEFBUTTON2 "Do you want to add $INSTDIR\bin to the PATH?" IDNO +3
    Push "$INSTDIR\bin"
    Call AddToPath
SectionEnd


;;;; Uninstaller code ;;;;

Function un.onInit
  MessageBox MB_ICONQUESTION|MB_YESNO|MB_DEFBUTTON2 "Are you sure you want to completely remove $(^Name) and all of its components?" IDYES +2
  Abort
FunctionEnd

Function un.onUninstSuccess
  HideWindow
  MessageBox MB_ICONINFORMATION|MB_OK "$(^Name) was successfully removed from your computer."
FunctionEnd

Section Uninstall
  !insertmacro MUI_STARTMENU_GETFOLDER Application $MUI_STARTMENUPAGE_VARIABLE

  Delete "$INSTDIR\gputils.url"

  DeleteRegValue HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\gputils" "NSIS:StartMenuDir"
  DeleteRegKey HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\gputils"

  Delete "$SMPROGRAMS\$MUI_STARTMENUPAGE_VARIABLE\GPL 2 License.lnk"
  Delete "$SMPROGRAMS\$MUI_STARTMENUPAGE_VARIABLE\Change Log.lnk"
  Delete "$SMPROGRAMS\$MUI_STARTMENUPAGE_VARIABLE\README.lnk"
  Delete "$SMPROGRAMS\$MUI_STARTMENUPAGE_VARIABLE\Documentation.lnk"
  Delete "$SMPROGRAMS\$MUI_STARTMENUPAGE_VARIABLE\Uninstall gputils.lnk"
  Delete "$SMPROGRAMS\$MUI_STARTMENUPAGE_VARIABLE\gputils on the Web.lnk"
  RMDir "$SMPROGRAMS\$MUI_STARTMENUPAGE_VARIABLE"

  ; Remove from PATH
  Push "$INSTDIR\bin"
  Call un.RemoveFromPath

  ; Remove environment variables
  Push "GPUTILS_HEADER_PATH"  ; name
  Call un.DeleteEnvStr
  Push "GPUTILS_LKR_PATH"     ; name
  Call un.DeleteEnvStr

  Delete "$INSTDIR\bin\gpal.exe"
  Delete "$INSTDIR\bin\gpasm.exe"
  Delete "$INSTDIR\bin\gplink.exe"
  Delete "$INSTDIR\bin\gplib.exe"
  Delete "$INSTDIR\bin\gpvc.exe"
  Delete "$INSTDIR\bin\gpvo.exe"
  RMDir "$INSTDIR\bin"

  Delete "$INSTDIR\lkr\*.lkr"
  RMDir "$INSTDIR\lkr"

  Delete "$INSTDIR\pub\*.pub"
  RMDir "$INSTDIR\pub"

  Delete "$INSTDIR\header\*.inc"
  RMDir "$INSTDIR\header"

  Delete "$INSTDIR\doc\*.pdf"
  RMDir "$INSTDIR\doc"

  Delete "$INSTDIR\uninstall.exe"
  Delete "$INSTDIR\ChangeLog.txt"
  Delete "$INSTDIR\README.txt"
  Delete "$INSTDIR\AUTHORS.txt"
  Delete "$INSTDIR\COPYING.txt"
  RMDir "$INSTDIR"

  SetAutoClose true
SectionEnd

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Path Manipulation functions                                                 ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

!verbose 3
!include "WinMessages.nsh"
!verbose 4

!ifdef ALL_USERS
  !define WriteEnvStr_RegKey \
     'HKLM "SYSTEM\CurrentControlSet\Control\Session Manager\Environment"'
!else
  !define WriteEnvStr_RegKey 'HKCU "Environment"'
!endif

; WriteEnvStr - Writes an environment variable
; Note: Win9x systems requires reboot
;
; Example:
;  Push "HOMEDIR"           ; name
;  Push "C:\New Home Dir\"  ; value
;  Call WriteEnvStr

Function WriteEnvStr
  Exch $1 ; $1 has environment variable value
  Exch
  Exch $0 ; $0 has environment variable name
  Push $2

  Call IsNT
  Pop $2
  StrCmp $2 1 WriteEnvStr_NT
    ; Not on NT
    StrCpy $2 $WINDIR 2 ; Copy drive of windows (c:)
    FileOpen $2 "$2\autoexec.bat" a
    Push $2
    Push "SET $0=$1"
    Call AppendToHandle
    FileClose $2
    SetRebootFlag true
    Goto WriteEnvStr_done

  WriteEnvStr_NT:
      WriteRegExpandStr ${WriteEnvStr_RegKey} $0 $1
      SendMessage ${HWND_BROADCAST} ${WM_WININICHANGE} \
        0 "STR:Environment" /TIMEOUT=5000

  WriteEnvStr_done:
    Pop $2
    Pop $1
    Pop $0
FunctionEnd

; un.DeleteEnvStr - Removes an environment variable
; Note: Win9x systems requires reboot
;
; Example:
;  Push "HOMEDIR"           # name
;  Call un.DeleteEnvStr

Function un.DeleteEnvStr
  Exch $0 ; $0 now has the name of the variable
  Push $1
  Push $2
  Push $3
  Push $4
  Push $5

  Call un.IsNT
  Pop $1
  StrCmp $1 1 DeleteEnvStr_NT
    ; Not on NT
    StrCpy $1 $WINDIR 2
    FileOpen $1 "$1\autoexec.bat" r
    GetTempFileName $4
    FileOpen $2 $4 w
    StrCpy $0 "SET $0="
    SetRebootFlag true

    DeleteEnvStr_dosLoop:
      FileRead $1 $3
      StrLen $5 $0
      StrCpy $5 $3 $5
      StrCmp $5 $0 DeleteEnvStr_dosLoop
      StrCmp $5 "" DeleteEnvStr_dosLoopEnd
      FileWrite $2 $3
      Goto DeleteEnvStr_dosLoop

    DeleteEnvStr_dosLoopEnd:
      FileClose $2
      FileClose $1
      StrCpy $1 $WINDIR 2
      Delete "$1\autoexec.bat"
      CopyFiles /SILENT $4 "$1\autoexec.bat"
      Delete $4
      Goto DeleteEnvStr_done

  DeleteEnvStr_NT:
    DeleteRegValue ${WriteEnvStr_RegKey} $0
    SendMessage ${HWND_BROADCAST} ${WM_WININICHANGE} \
      0 "STR:Environment" /TIMEOUT=5000

  DeleteEnvStr_done:
    Pop $5
    Pop $4
    Pop $3
    Pop $2
    Pop $1
    Pop $0
FunctionEnd

; AddToPath - Adds the given dir to the search path.
;        Input - head of the stack
;        Note - Win9x systems requires reboot

Function AddToPath
  Exch $0
  Push $1
  Push $2
  Push $3
  Push $4

  ; don't add if the path doesn't exist
  IfFileExists $0 "" AddToPath_done

  Call IsNT
  Pop $4
  StrCmp $4 1 +3
    ; Not on NT: read PATH from environment variable
    ReadEnvStr $1 PATH
    Goto +2
    ; On NT: read PATH from registry
    ReadRegStr $1 HKCU "Environment" "PATH"
  Push "$1;"
  Push "$0;"
  Call StrStr
  Pop $2
  StrCmp $2 "" "" AddToPath_done
  Push "$1;"
  Push "$0\;"
  Call StrStr
  Pop $2
  StrCmp $2 "" "" AddToPath_done
  GetFullPathName /SHORT $3 $0
  Push "$1;"
  Push "$3;"
  Call StrStr
  Pop $2
  StrCmp $2 "" "" AddToPath_done
  Push "$1;"
  Push "$3\;"
  Call StrStr
  Pop $2
  StrCmp $2 "" "" AddToPath_done

  StrCmp $4 1 AddToPath_NT
    ; Not on NT
    StrCpy $1 $WINDIR 2
    FileOpen $1 "$1\autoexec.bat" a
    Push $1
    Push "SET PATH=%PATH%;$3"
    Call AppendToHandle
    FileClose $1
    SetRebootFlag true
    Goto AddToPath_done

  AddToPath_NT:
    ReadRegStr $1 HKCU "Environment" "PATH"
    StrCpy $2 $1 1 -1  ; copy last char
    StrCmp $2 ";" 0 +2 ; if last char == ;
      StrCpy $1 $1 -1  ; remove last char
    StrCmp $1 "" AddToPath_NTdoIt
      StrCpy $0 "$1;$0"
    AddToPath_NTdoIt:
      WriteRegExpandStr HKCU "Environment" "PATH" $0
      SendMessage ${HWND_BROADCAST} ${WM_WININICHANGE} 0 "STR:Environment" /TIMEOUT=5000

  AddToPath_done:
    Pop $4
    Pop $3
    Pop $2
    Pop $1
    Pop $0
FunctionEnd

; RemoveFromPath - Remove a given dir from the path
;     Input: head of the stack

Function un.RemoveFromPath
  Exch $0
  Push $1
  Push $2
  Push $3
  Push $4
  Push $5
  Push $6

  IntFmt $6 "%c" 26 ; DOS EOF

  Call un.IsNT
  Pop $1
  StrCmp $1 1 unRemoveFromPath_NT
    ; Not on NT
    StrCpy $1 $WINDIR 2
    FileOpen $1 "$1\autoexec.bat" r
    GetTempFileName $4
    FileOpen $2 $4 w
    GetFullPathName /SHORT $0 $0
    StrCpy $0 "SET PATH=%PATH%;$0"

    unRemoveFromPath_dosLoop:
      FileRead $1 $3
      StrCpy $5 $3 1 -1 ; read last char
      StrCmp $5 $6 0 +2 ; if DOS EOF
        StrCpy $3 $3 -1 ; remove DOS EOF so we can compare
      StrCmp $3 "$0$\r$\n" unRemoveFromPath_dosLoopRemoveLine
      StrCmp $3 "$0$\n" unRemoveFromPath_dosLoopRemoveLine
      StrCmp $3 "$0" unRemoveFromPath_dosLoopRemoveLine
      StrCmp $3 "" unRemoveFromPath_dosLoopEnd
      FileWrite $2 $3
      Goto unRemoveFromPath_dosLoop
      unRemoveFromPath_dosLoopRemoveLine:
        SetRebootFlag true
        Goto unRemoveFromPath_dosLoop

    unRemoveFromPath_dosLoopEnd:
      FileClose $2
      FileClose $1
      StrCpy $1 $WINDIR 2
      Delete "$1\autoexec.bat"
      CopyFiles /SILENT $4 "$1\autoexec.bat"
      Delete $4
      Goto unRemoveFromPath_done

  unRemoveFromPath_NT:
    ReadRegStr $1 HKCU "Environment" "PATH"
    StrCpy $5 $1 1 -1 ; copy last char
    StrCmp $5 ";" +2  ; if last char != ;
      StrCpy $1 "$1;" ; append ;
    Push $1
    Push "$0;"
    Call un.StrStr    ; Find `$0;` in $1
    Pop $2            ; pos of our dir
    StrCmp $2 "" unRemoveFromPath_done
      ; else, it is in path
      ; $0 - path to add
      ; $1 - path var
      StrLen $3 "$0;"
      StrLen $4 $2
      StrCpy $5 $1 -$4   ; $5 is now the part before the path to remove
      StrCpy $6 $2 "" $3 ; $6 is now the part after the path to remove
      StrCpy $3 $5$6

      StrCpy $5 $3 1 -1  ; copy last char
      StrCmp $5 ";" 0 +2 ; if last char == ;
        StrCpy $3 $3 -1  ; remove last char

      StrCmp $3 "" +3
        ; New PATH not empty: update the registry
        WriteRegExpandStr HKCU "Environment" "PATH" $3
        Goto +2
        ; New PATH empty: remove from the registry
        DeleteRegValue HKCU "Environment" "PATH"
      SendMessage ${HWND_BROADCAST} ${WM_WININICHANGE} 0 "STR:Environment" /TIMEOUT=5000

  unRemoveFromPath_done:
    Pop $6
    Pop $5
    Pop $4
    Pop $3
    Pop $2
    Pop $1
    Pop $0
FunctionEnd

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;            Utility Functions            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; AppendToHandle
;
; Example:
;  Push $1                ; file handle
;  Push "Line to append"  ; line
;  Call AppendToHandle

!macro AppendToHandle
Function AppendToHandle
  Exch $1 ; $1 line
  Exch
  Exch $0 ; $0 file handle
  Push $2 ; Last char EOF

  FileSeek $0 -1 END
  FileReadByte $0 $2
  IntCmp $2 26 0 +2 +2 ; DOS EOF
    FileSeek $0 -1 END ; write over EOF
  FileWrite $0 "$\r$\n$1"

  Pop $2
  Pop $1
  Pop $0
FunctionEnd
!macroend
!insertmacro AppendToHandle

; IsNT
; no input
; output, top of the stack = 1 if NT or 0 if not
;
; Usage:
;   Call IsNT
;   Pop $R0
;  ($R0 at this point is 1 or 0)

!macro IsNT un
Function ${un}IsNT
  Push $0
  ReadRegStr $0 HKLM "SOFTWARE\Microsoft\Windows NT\CurrentVersion" CurrentVersion
  StrCmp $0 "" 0 IsNT_yes
  ; we are not NT.
  Pop $0
  Push 0
  Return

  IsNT_yes:
    ; NT!!!
    Pop $0
    Push 1
FunctionEnd
!macroend
!insertmacro IsNT ""
!insertmacro IsNT "un."

; StrStr
; input, top of stack = string to search for
;        top of stack-1 = string to search in
; output, top of stack (replaces with the portion of the string remaining)
; modifies no other variables.
;
; Usage:
;   Push "this is a long ass string"
;   Push "ass"
;   Call StrStr
;   Pop $R0
;  ($R0 at this point is "ass string")

!macro StrStr un
Function ${un}StrStr
Exch $R1   ; st=haystack,old$R1, $R1=needle
  Exch     ; st=old$R1,haystack
  Exch $R2 ; st=old$R1,old$R2, $R2=haystack
  Push $R3
  Push $R4
  Push $R5
  StrLen $R3 $R1
  StrCpy $R4 0
  ; $R1=needle
  ; $R2=haystack
  ; $R3=len(needle)
  ; $R4=cnt
  ; $R5=tmp
  loop:
    StrCpy $R5 $R2 $R3 $R4
    StrCmp $R5 $R1 done
    StrCmp $R5 "" done
    IntOp $R4 $R4 + 1
    Goto loop
done:
  StrCpy $R1 $R2 "" $R4
  Pop $R5
  Pop $R4
  Pop $R3
  Pop $R2
  Exch $R1
FunctionEnd
!macroend
!insertmacro StrStr ""
!insertmacro StrStr "un."

